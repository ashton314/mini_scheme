This works fine:

(define zoop (gensym))
(define narf (+ zoop 0))

(eq? narf zoop)

But this:

(= narf zoop)

returns #t. This should be a fairly easy fix with the `=' operator.


The block below lists some bugs present in branch "array". These bugs
have been elimiated by reverting back to Cons objects. The program
will slow down again, and I'm keeping it this way, until I can find a
way (if even possible) to extract a array slice ref. Sadness.

INCORRECT: {
The following:

  (define foo '(1 2 3))
  (define zoop foo)

  (eq? foo zoop)			; Returns #t: This is good.
  (eq? (cdr foo) (cdr zoop))		; Returns #f: This is VERY VERY BAD!!

How am I going to fix that? Will I have to use nested arrays like so:

  [1, [2, [3, nil]]]

Will that drop my speed? Most likely. Is there any way around this? I
cannot think of any at the moment. Fie.

On the plus side, nested arrays like this will be easier to write
cons() and dotted notation with. On the down side, this could be a
major performance penalty.

Add flat arrays as a data type for speed? I'll still need the lists,
though. Fie.
}
